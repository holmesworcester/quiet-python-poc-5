"""Job scheduler handler for periodic task execution."""

import sqlite3
from typing import List, Dict, Any
from core.handlers import Handler
from core.jobs import load_job_definitions, is_job_due, mark_job_run
from core.commands import get_command_registry
import time


class JobSchedulerHandler(Handler):
    """
    Handler that checks for and executes due jobs.

    This handler should run early in the pipeline to inject job-generated
    envelopes for processing.
    """

    @property
    def name(self) -> str:
        return "job_scheduler"

    def filter(self, envelope: Dict[str, Any]) -> bool:
        """
        Process special job tick envelopes or periodic checks.
        """
        # Process explicit job ticks
        if envelope.get('type') == 'job_tick':
            return True

        # Also check on any envelope (rate limited)
        # This ensures jobs run even without explicit ticks
        last_check = getattr(self, '_last_job_check', 0)
        current_time = time.time()
        if current_time - last_check > 1.0:  # Check at most once per second
            self._last_job_check = current_time
            return True

        return False

    def process(self, envelope: Dict[str, Any], db: sqlite3.Connection) -> List[Dict[str, Any]]:
        """
        Check for due jobs and execute them.

        Returns:
            List of envelopes generated by job commands
        """
        # Load job definitions
        jobs = load_job_definitions()
        if not jobs:
            return []

        generated_envelopes = []
        command_registry = get_command_registry()

        for job in jobs:
            job_name = job.get('name')
            command_name = job.get('command')
            frequency_ms = job.get('frequency_ms', 60000)  # Default 1 minute
            params = job.get('params', {})

            if not job_name or not command_name:
                continue

            # Check if job is due
            if not is_job_due(db, job_name, frequency_ms):
                continue

            # Get the command function
            command_func = command_registry.get(command_name)
            if not command_func:
                print(f"Warning: Command '{command_name}' not found for job '{job_name}'")
                continue

            try:
                # Prepare parameters (substitute runtime values)
                runtime_params = self._prepare_params(params, envelope, db)

                # Execute the command
                result = command_func(runtime_params)

                # Commands can return either a single envelope or a list
                if isinstance(result, dict):
                    generated_envelopes.append(result)
                elif isinstance(result, list):
                    generated_envelopes.extend(result)

                # Mark job as run
                mark_job_run(db, job_name)

                print(f"Job '{job_name}' executed successfully")

            except Exception as e:
                print(f"Error executing job '{job_name}': {e}")
                # Still mark as run to avoid rapid retries
                mark_job_run(db, job_name)

        return generated_envelopes

    def _prepare_params(self, params: Dict[str, Any], envelope: Dict[str, Any],
                       db: sqlite3.Connection) -> Dict[str, Any]:
        """
        Prepare job parameters by substituting runtime values.

        Supports templates like:
        - {network_id}: Current network ID
        - {peer_id}: Current peer ID
        - {user_id}: Current user ID
        - {local_ip}: Local IP address

        Args:
            params: Parameter template
            envelope: Current envelope (for context)
            db: Database connection

        Returns:
            Parameters with substituted values
        """
        runtime_params = {}

        for key, value in params.items():
            if isinstance(value, str) and value.startswith('{') and value.endswith('}'):
                # This is a template - substitute runtime value
                template_key = value[1:-1]  # Remove braces

                if template_key == 'network_id':
                    # Get from envelope or query DB for active network
                    runtime_value = envelope.get('network_id', self._get_active_network(db))
                elif template_key == 'peer_id':
                    runtime_value = envelope.get('peer_id', self._get_active_peer(db))
                elif template_key == 'user_id':
                    runtime_value = envelope.get('user_id', self._get_active_user(db))
                elif template_key == 'local_ip':
                    runtime_value = '127.0.0.1'  # Default for now
                else:
                    runtime_value = value  # Keep as-is if unknown template

                runtime_params[key] = runtime_value
            else:
                # Not a template, use as-is
                runtime_params[key] = value

        return runtime_params

    def _get_active_network(self, db: sqlite3.Connection) -> str:
        """Get the active network ID from database."""
        cursor = db.cursor()
        result = cursor.execute(
            "SELECT network_id FROM networks WHERE is_active = 1 LIMIT 1"
        ).fetchone()
        return result[0] if result else ''

    def _get_active_peer(self, db: sqlite3.Connection) -> str:
        """Get the active peer ID from database."""
        cursor = db.cursor()
        result = cursor.execute(
            "SELECT peer_id FROM peers WHERE is_self = 1 LIMIT 1"
        ).fetchone()
        return result[0] if result else ''

    def _get_active_user(self, db: sqlite3.Connection) -> str:
        """Get the active user ID from database."""
        cursor = db.cursor()
        result = cursor.execute(
            "SELECT user_id FROM users WHERE is_self = 1 LIMIT 1"
        ).fetchone()
        return result[0] if result else ''


def create_job_tick() -> Dict[str, Any]:
    """
    Create a job tick envelope to trigger job checks.

    Returns:
        Envelope that triggers JobSchedulerHandler
    """
    return {
        'type': 'job_tick',
        'timestamp_ms': int(time.time() * 1000)
    }