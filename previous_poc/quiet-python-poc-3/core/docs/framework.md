```markdown
## Prompt for LLM Coding Assistant

* `incoming` is now just a handler with a job, run by tick. it still uses handle.py, provided by core, to pass along to other handlers. 

### Overview
You are building a POC Python implementation of a minimal P2P event-driven framework for local-first apps (e.g., chat). Use Python 3.12+ with a virtual environment. Follow this directory structure: core/ (tick.py, greedy_decrypt.py, handle.py, test_runner.py), utils/ (crypto/ with crypto.py and handler.json for tests), handlers/ (e.g., message/ with handler.json and separate .py files per function like projector.py, create.py; add missing_key/ and unknown/ for meta-handlers). Use dict-based DB for now (per-identity eventStore/state, e.g., db['eventStore']['pubkey'] = []), later replace with SQLAlchemy. Implement real crypto via thin wrappers in core/crypto.py around libsodium (for sign/verify, encrypt/decrypt, KDF, secure_random, hash; install via pip if needed in venv). Focus on handlers first; make all tests real and passing. Drop envelope types/adapter graphs; handlers own signing for canonical events, projectors handle encryption for self-generated outgoing using crypto wrappers. Tick uses greedy_decrypt to unwrap incoming to a standard envelope dict ({"payload": dict/str, "metadata": dict}) passed to handlers via handle.

### Explanations of Core Components
- **Greedy Decrypt and Standard Envelope**: greedy_decrypt.py unwraps incoming raw blobs greedily (transit → inner layers), returning a standard envelope dict or None (for drop on decrypt fail with known key). Envelope: {"payload": decrypted_data (dict/str, fully decrypted if successful), "metadata": {"outerKeyHash": str, "innerKeyHash": str, "origin": str, "receivedAt": int, "error": str (if partial/missing key), "selfGenerated": bool (true for self-events)}}. If missing key, return partial envelope for routing to missing_key handler. Handlers receive this envelope uniformly; projectors update state based on payload/metadata (e.g., verify sig in payload using metadata keys; if "selfGenerated": true, encrypt payload and append to db["outgoing"], potentially via helper function like encrypt_for_outgoing).
- **Handlers**: Each event type (e.g., message) has handler.json with projector (validates/updates state from envelope; adds to state for both incoming and self-generated events for symmetry; if selfGenerated, also encrypts/sends to outgoing *if* this event creationg or handling requires sending outgoing data), commands (e.g., create returns {"return": value, "newEvents": [canonical_events]} – plaintext/signed; caller creates envelopes with selfGenerated=true and calls handle to project them). No focus on jobs yet here. Pending tables will be queried by projectors when new events come in that may block items. Each function in its own .py (e.g., create.py calls crypto.sign for canonical). Tests are language-neutral JSON in handler.json (given db/envelope/params, then db/return/newEvents/error; include metadata in given for readability, e.g., selfGenerated cases). Runner executes them, chains if needed (use prior test outputs in next), and returns detailed results/logs (e.g., step-by-step execution, full state on error) to enable debugging without custom code. Add meta-handlers: missing_key/ (projects partials to state["pending_missing_key"] with metadata/error/missingHash/inNetwork; projectors retry on key_map changes (e.g. from a succesfully unsealed incoming key event) and remove once projected) and unknown/ (for decrypted but unrecognized types; projects to state["unknown_events"] with payload/metadata; purge old via job).
- **Tick and Handle**: tick.py drains incoming (raw blobs), calls greedy_decrypt per item; if envelope["metadata"].get("error"), route to missing_key projector; else get handler by payload["type"] or route to unknown; call projector with envelope/db/current_identity/time_now_ms. Projectors store network-verified events in per-identity eventStore (projectors manage identity themselves; this is not in core) even if invalid, but skip state update until valid. Runs jobs last (e.g., scan pending tables, re-decrypt/process/remove). For self-generated events (from commands), caller creates envelope with payload=canonical, metadata={"selfGenerated": true, ...}, calls handle directly (symmetric to incoming). Tests for tick: JSON in core/tick.json covering full cycles (e.g., given db with incoming/outgoing, then db after tick; permute events for idempotence and eventual consistency (all projections of permuted events should be identical); simulate multi-identity network via network-simulator job). Runner handles these too, with logs for each step (e.g., decrypt outcome, projection result).
- **Test Runner**: Single runner in core/test_runner.py tests all handlers/tick via their JSON. Executes given/then (e.g., setup db, run function, compare output/db/error). For chains: build them sequentially "by hand", using prior returns in to make the next test. Returns all results/logs (pass/fail per test, full state snapshots, detailed errors with why/where/trace, intermediate values like envelopes/event_ids). Emphasize: *Only* use JSON tests for handlers/projectors/commands (no freestyle tests/debug code); focus debugging on runner outputs. Test the runner itself with its own JSON tests (e.g., mock handler.json with edge cases) for coverage/observability and with handlers in `framework_tests` folder. If error, relay detailed messages (e.g., "Validation failed: signature mismatch, expected X got Y, state: {db}").

### Build Instructions
1. Create venv, install libsodium/pyca/cryptography for crypto.
2. Implement test_runner.py first; test it with its own JSON tests covering execution, chaining, errors, permutations (e.g., event order idempotence for projectors).
3. Implement greedy_decrypt.py; test via runner with JSON in core/greedy_decrypt.json (given raw_blob/db, then envelope or null; include missing key/drop cases).
4. For each handler (incl. meta): Write handler.json with required fields/lengths (add schema check in runner for structural validity). Implement functions in separate .py, run tests via runner, fix based on logs (never add debug prints; use runner observability).
5. Use real crypto: crypto.py wrappers (e.g., libsodium.sign, .encrypt); tests in utils/crypto/handler.json (use two identities in same network for end-to-end, e.g., generate data in one test, use in next via prior output).
6. Always run all tests before reporting completion; fix errors or ask for clarification.
7. Get as far as possible; ask clarifying questions if stuck (e.g., on decrypt params).

### Invariants (Remember Always)
- Never drop events unless structurally invalid (runner-checked via schema), expired, deleted, from removed user, or decrypt fails with known key (treated as invalid). Store network-verified events; projectors skip invalid until valid (e.g., re-project on dependency).
- Event_id: Hash of whole canonical event (json.dumps(payload, sort_keys=True) post-decrypt or for self; added to metadata in greedy_decrypt or handle for O(1) dup check in projectors; never in payload to avoid hash loop).
- Keep the hash of the "inner" event-layer encrypted event in envelope / projection, this can be the id until we have a canonical event_id from the signed plaintext event. keep hash of encrypted too 
- Debugging: Only via runner logs/results; enhance runner observability (detailed errors, state snapshots) with tests for it.
- Tests: Language-neutral JSON only for handlers/projectors/commands; chain via prior outputs; include pass/fail for validation (pending/dropped cases); separate metadata in given for readability.
- Encryption: tests can toggle dummy or real mode for encryption readability; always real in code.