# Transactions and Concurrency in the Event-Driven Framework

## Overview

This document describes the transaction model, concurrency considerations, and dependency management in the event-driven P2P messaging framework. It covers both the current implementation and potential improvements for handling concurrent event processing.

## Current Transaction Model

### Transaction Hierarchy

The system uses a hierarchical transaction model with clear ownership:

1. **Commands own transactions**: Each command execution starts a transaction that encompasses:
   - The command execution itself
   - All events generated by that command
   - All projections triggered by those events

2. **Events participate in transactions**: When `handle()` is called:
   - With `auto_transaction=True`: Creates a new transaction (for external events)
   - With `auto_transaction=False`: Participates in existing transaction (for command-generated events)

3. **Database locking**: Uses SQLite's `BEGIN EXCLUSIVE` which locks the entire database for writes

### Code Flow

```
Command Execution:
├── BEGIN TRANSACTION
├── Execute command logic
├── For each generated event:
│   └── handle(event, auto_transaction=False)
│       ├── Load projector
│       ├── Run projection
│       └── Update state
├── COMMIT (if all successful)
└── ROLLBACK (if any failure)
```

## Concurrency Challenges

### 1. Lost Dependency Resolution

**Problem**: Events that depend on each other may be processed concurrently, causing valid events to be blocked.

```
Time  Transaction A (User)    Transaction B (Message)
t0    BEGIN                   BEGIN
t1    Read state (no user)    Read state (no user)
t2    Add user "alice"        See no user "alice"
t3    COMMIT                  Block message (missing alice)
t4                            COMMIT
```

**Result**: Message is permanently blocked even though its dependency was satisfied.

### 2. Phantom Unblocking

**Problem**: Unblocking logic may try to reprocess events before their dependencies are visible.

```
Time  Transaction A (Unblock)  Transaction B (New Event)
t0    BEGIN                    BEGIN
t1    Read blocked list        
t2    Find msg depends on X    
t3    Unblock & reprocess      Add event X
t4    Msg fails again (no X)   
t5    Re-block msg             COMMIT
t6    COMMIT
```

### 3. Double Processing

**Problem**: The same event could be processed multiple times if unblocking happens concurrently.

```
Time  Transaction A           Transaction B
t0    Process user event      
t1    Unblock msg_123         Read blocked list
t2    Process msg_123         See msg_123 blocked
t3    COMMIT                  Unblock msg_123
t4                           Process msg_123
t5                           COMMIT
```

### 4. Authorization Race Conditions

**Invite Revocation Race**:
```
Time  Transaction A (Revoke)  Transaction B (Join)
t0    Check invite valid      Check invite valid
t1    Both see valid invite   
t2    Mark invite revoked     Use invite to join
t3    COMMIT                  COMMIT
```

**Permission Changes**:
- User performs action while permissions are being revoked
- Signature verification fails because key isn't visible yet
- Access control checks see stale state

### 5. Circular Dependencies

Without proper cycle detection, events could create circular dependencies:
- Event A depends on Event B
- Event B depends on Event C  
- Event C depends on Event A

## Current Implementation Details

### Transaction Isolation

```python
# From core/db.py
def begin_transaction(self):
    if self._in_transaction:
        raise RuntimeError("Transaction already in progress")
    self._in_transaction = True
    self._transaction_cache = {}
    self.conn.execute("BEGIN EXCLUSIVE")  # Full database lock
```

### Nested Transaction Issue

Commands cannot call other commands that need transactions:

```python
# This fails in unblock.py:
def execute(params, db):
    # ... find blocked events ...
    for event in unblocked_events:
        db = handle(db, event, time_now_ms=1000)  # Would try to start nested transaction
```

**Current workaround**: Use `auto_transaction=False` for nested operations.

## Dependency Management

### Blocking Events

Events are blocked when dependencies aren't met:

```python
# Example from user projector
if not invite_found:
    blocked_reason = f"Invite {invite_id} not found"
    blocked.append({
        'event_id': user_id,
        'blocked_by': invite_id,
        'reason': blocked_reason
    })
```

### Unblocking Events

The unblock command finds and reprocesses blocked events:

```python
def execute(params, db):
    event_id = params.get('eventId')
    # Find events blocked by this event_id
    for blocked_event in blocked:
        if blocked_event.get('blocked_by') == event_id:
            # Reprocess the event
```

## Potential Improvements

### 1. Event Queue Model (Most Scalable)

Separate command execution from event projection:

```
Command -> Generate Events -> Event Queue -> Async Projectors
         \________________/                \_______________/
           Transaction 1                    Transaction 2,3,4...
```

**Pros**: 
- Horizontal scaling
- Better fault isolation
- Natural retry mechanism

**Cons**:
- Eventual consistency
- More complex infrastructure

### 2. Explicit Dependency Tracking

Instead of checking state, track dependencies explicitly:

```python
blocked_events = {
    "msg_123": {
        "dependencies": ["user:alice", "channel:general"],
        "attempts": 3,
        "last_attempt": timestamp,
        "created_at": timestamp
    }
}
```

### 3. Savepoints for Nested Operations

Replace nested transactions with savepoints:

```python
if self._in_transaction:
    self.conn.execute("SAVEPOINT sp1")
    try:
        # ... operation ...
        self.conn.execute("RELEASE sp1")
    except:
        self.conn.execute("ROLLBACK TO sp1")
else:
    self.begin_transaction()
```

### 4. Read-Through Consistency

For critical checks, read through to the event store:

```python
def user_exists(user_id, db):
    # First check projected state
    if user_in_state(user_id, db):
        return True
    
    # Then check uncommitted events in current transaction
    if user_in_transaction_cache(user_id, db):
        return True
    
    # Finally check event store
    return user_in_event_store(user_id, db)
```

### 5. Garbage Collection for Blocked Events

Periodic job to retry old blocked events:

```python
def garbage_collect_blocked():
    for blocked_event in get_old_blocked_events():
        if should_retry(blocked_event):
            queue_for_reprocessing(blocked_event)
        elif is_too_old(blocked_event):
            mark_as_permanently_failed(blocked_event)
```

### 6. Optimistic Concurrency Control

Use version numbers or timestamps:

```python
def update_with_version_check(key, value, expected_version):
    current_version = get_version(key)
    if current_version != expected_version:
        raise ConcurrentModificationError()
    set_with_new_version(key, value, current_version + 1)
```

## Recommendations

### For Immediate Implementation

1. **Add garbage collection**: Implement a periodic job to retry blocked events
2. **Track attempt counts**: Prevent infinite retry loops
3. **Use savepoints**: Handle nested operations properly
4. **Add cycle detection**: Prevent circular dependencies

### For Long-term Scalability

1. **Event ordering**: Use vector clocks or Lamport timestamps
2. **Separate read/write paths**: Use read replicas for queries
3. **Event queue**: Decouple command execution from projection
4. **Sharding strategy**: Partition by identity or network

## Design Principles

1. **Consistency over availability**: The system prioritizes correctness
2. **Local-first**: Each identity maintains its own view
3. **Eventually consistent**: Events can be processed in any order
4. **Idempotent operations**: Reprocessing events should be safe

## Testing Considerations

When testing concurrent scenarios:

1. Use explicit event ordering in tests
2. Test both "happy path" and race conditions
3. Verify idempotency of projectors
4. Test garbage collection scenarios
5. Ensure no events are lost or duplicated

## Conclusion

The current transaction model provides strong consistency guarantees but has limitations for concurrent processing. The blocking/unblocking mechanism is robust but needs garbage collection and better dependency tracking. Future improvements should focus on:

1. Making the system more resilient to timing issues
2. Preventing duplicate processing
3. Ensuring all valid events are eventually processed
4. Maintaining security properties under concurrent access

The trade-offs between consistency, availability, and partition tolerance should be carefully considered based on the specific requirements of each protocol implementation.