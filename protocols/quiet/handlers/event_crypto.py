"""
Event Crypto handler - Handles encryption, decryption, and key unsealing.

From plan.md:
- Decrypt Filter: `deps_included_and_valid: true` AND `should_remove: false` AND `event_key_id` exists AND no `event_plaintext`
- Encrypt Filter: `validated: true` AND has `event_plaintext` AND no `event_ciphertext`
- Transform: Encrypts/decrypts events or unseals key events
"""

from core.types import Envelope


def filter_func(envelope: Envelope) -> bool:
    """
    Process envelopes that need event-level crypto operations.
    """
    # Decrypt/unseal case: has key_ref but no plaintext
    if (envelope.get('deps_included_and_valid') is True and
        envelope.get('should_remove') is False and
        'key_ref' in envelope and
        'event_plaintext' not in envelope):
        return True
    
    # Encrypt case: validated plaintext that needs encryption
    if (envelope.get('validated') is True and
        'event_plaintext' in envelope and
        'event_ciphertext' not in envelope):
        return True
    
    return False


def handler(envelope: Envelope) -> Envelope:
    """
    Handle event-level crypto operations.
    
    Args:
        envelope: Envelope needing crypto operations
        
    Returns:
        Transformed envelope
    """
    # Determine operation type
    if 'key_ref' in envelope and 'event_plaintext' not in envelope:
        # Decrypt or unseal based on key_ref type
        key_ref = envelope['key_ref']
        
        if isinstance(key_ref, dict) and key_ref.get('kind') == 'peer':
            # Key event - unseal using KEM to peer/prekey
            return unseal_key_event(envelope)
        elif isinstance(key_ref, dict) and key_ref.get('kind') == 'key':
            # Regular event - decrypt using symmetric key
            return decrypt_event(envelope)
        else:
            envelope['error'] = f"Invalid key_ref: {key_ref}"
            return envelope
    else:
        # Encrypt
        return encrypt_event(envelope)


def unseal_key_event(envelope: Envelope) -> Envelope:
    """Unseal a key event using peer's identity and KEM."""
    # TODO: Implement actual KEM unsealing logic
    
    # Would normally:
    # 1. Get identity from resolved_deps
    # 2. Get prekey private key from local storage
    # 3. Use crypto_box_seal_open with prekey to unseal
    # 4. Extract key_id, unsealed_secret, group_id
    
    # Key events use KEM (crypto_box_seal) to prekeys
    envelope['event_type'] = 'key'
    envelope['key_id'] = f"key_{envelope['event_key_id']}"  # Stub
    envelope['unsealed_secret'] = b'stub_unsealed_secret'  # Stub
    envelope['group_id'] = 'stub_group_id'  # Stub
    envelope['prekey_id'] = 'stub_prekey_id'  # Which prekey was used
    envelope['tag_id'] = 'stub_tag_id'  # KEM tag
    envelope['write_to_store'] = True
    
    # Key events bypass signature verification
    envelope['sig_checked'] = True  # Mark as checked to skip sig handler
    envelope['validated'] = True    # Key events are self-validating after unsealing
    
    return envelope


def decrypt_event(envelope: Envelope) -> Envelope:
    """Decrypt a regular event."""
    # TODO: Implement actual decryption logic
    
    # Would normally:
    # 1. Get key from resolved_deps using event_key_id
    # 2. Decrypt event_ciphertext using the key
    # 3. Parse decrypted data as event_plaintext
    
    # Stub implementation
    envelope['event_plaintext'] = {
        'type': envelope.get('event_type', 'unknown'),
        'content': 'stub_decrypted_content'
    }
    
    # Extract event_type from plaintext if not already set
    if 'event_type' not in envelope and 'type' in envelope['event_plaintext']:
        envelope['event_type'] = envelope['event_plaintext']['type']
    
    # Note: event_id is generated by signature_handler from canonical signed plaintext
    # It should already be present in the envelope
    
    envelope['write_to_store'] = True
    
    return envelope


def encrypt_event(envelope: Envelope) -> Envelope:
    """Encrypt a validated plaintext event."""
    # TODO: Implement actual encryption logic
    
    # Would normally:
    # 1. Determine which key to use for encryption (from network/group context)
    # 2. Serialize event_plaintext to canonical 512-byte form
    # 3. Encrypt the serialized data
    # 4. Set key_ref to indicate which key was used
    
    event_plaintext = envelope.get('event_plaintext', {})
    
    # Stub: Use a deterministic "encryption" for testing
    plaintext_str = str(event_plaintext)
    envelope['event_ciphertext'] = f"encrypted:{plaintext_str}".encode()
    
    # Determine key_ref (would normally come from group/network context)
    if 'group_id' in event_plaintext:
        # Group events use symmetric key encryption
        envelope['key_ref'] = {
            'kind': 'key',
            'id': f"group_key_{event_plaintext['group_id']}"
        }
    else:
        # Network events might use peer encryption
        peer_id = event_plaintext.get('peer_id', envelope.get('peer_id', 'default_peer'))
        envelope['key_ref'] = {
            'kind': 'peer',
            'id': peer_id
        }
    
    # Note: event_id should already be present from signature_handler
    # The event_id is the blake2b-16 hash of the canonical signed plaintext
    if 'event_id' not in envelope:
        envelope['error'] = "No event_id found - should be set by signature_handler"
    
    envelope['write_to_store'] = True
    
    return envelope