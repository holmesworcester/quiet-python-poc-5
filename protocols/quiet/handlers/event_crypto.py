"""
Event Crypto handler - Handles encryption, decryption, and key unsealing.

From plan.md:
- Decrypt Filter: `deps_included_and_valid: true` AND `should_remove: false` AND `event_key_id` exists AND no `event_plaintext`
- Encrypt Filter: `validated: true` AND has `event_plaintext` AND no `event_ciphertext`
- Transform: Encrypts/decrypts events or unseals key events
"""
from typing import Any, List
import sqlite3
from core.handlers import Handler

# Removed core.types import


def filter_func(envelope: dict[str, Any]) -> bool:
    """
    Process envelopes that need event-level crypto operations.
    """
    # Decrypt/unseal case: has key_ref but no plaintext
    if (envelope.get('deps_included_and_valid') is True and
        envelope.get('should_remove') is False and
        'key_ref' in envelope and
        'event_plaintext' not in envelope):
        return True

    # Encrypt case: validated plaintext that needs encryption
    if (envelope.get('validated') is True and
        'event_plaintext' in envelope and
        'event_ciphertext' not in envelope):
        return True

    # Seal case: has seal_to field and plaintext
    if ('seal_to' in envelope and
        'event_plaintext' in envelope and
        'event_sealed' not in envelope):
        return True

    # Open sealed case: has event_sealed but no plaintext
    if ('event_sealed' in envelope and
        'event_plaintext' not in envelope):
        return True

    return False


def handler(envelope: dict[str, Any]) -> dict[str, Any]:
    """
    Handle event-level crypto operations.

    Args:
        envelope: dict[str, Any] needing crypto operations

    Returns:
        Transformed envelope
    """
    # Handle seal operation (for sync requests)
    if 'seal_to' in envelope and 'event_plaintext' in envelope:
        return seal_event(envelope)

    # Handle open sealed operation (for received sync requests)
    if 'event_sealed' in envelope and 'event_plaintext' not in envelope:
        return open_sealed_event(envelope)

    # Determine operation type for regular crypto
    if 'key_ref' in envelope and 'event_plaintext' not in envelope:
        # Decrypt or unseal based on key_ref type
        key_ref = envelope['key_ref']

        if isinstance(key_ref, dict) and key_ref.get('kind') == 'peer':
            # Key event - unseal using KEM to peer/prekey
            return unseal_key_event(envelope)
        elif isinstance(key_ref, dict) and key_ref.get('kind') == 'key':
            # Regular event - decrypt using symmetric key
            return decrypt_event(envelope)
        else:
            envelope['error'] = f"Invalid key_ref: {key_ref}"
            return envelope
    else:
        # Encrypt
        return encrypt_event(envelope)


def unseal_key_event(envelope: dict[str, Any]) -> dict[str, Any]:
    """Unseal a key event using peer's identity and KEM."""
    # TODO: Implement actual KEM unsealing logic
    
    # Would normally:
    # 1. Get identity from resolved_deps
    # 2. Get prekey private key from local storage
    # 3. Use crypto_box_seal_open with prekey to unseal
    # 4. Extract key_id, unsealed_secret, group_id
    
    # Key events use KEM (crypto_box_seal) to prekeys
    envelope['event_type'] = 'key'
    envelope['key_id'] = f"key_{envelope['event_key_id']}"  # Stub
    envelope['unsealed_secret'] = b'stub_unsealed_secret'  # Stub
    envelope['group_id'] = 'stub_group_id'  # Stub
    envelope['prekey_id'] = 'stub_prekey_id'  # Which prekey was used
    envelope['tag_id'] = 'stub_tag_id'  # KEM tag
    envelope['write_to_store'] = True
    
    # Key events bypass signature verification
    envelope['sig_checked'] = True  # Mark as checked to skip sig handler
    envelope['validated'] = True    # Key events are self-validating after unsealing
    
    return envelope


def decrypt_event(envelope: dict[str, Any]) -> dict[str, Any]:
    """Decrypt a regular event."""
    # TODO: Implement actual decryption logic
    
    # Would normally:
    # 1. Get key from resolved_deps using event_key_id
    # 2. Decrypt event_ciphertext using the key
    # 3. Parse decrypted data as event_plaintext
    
    # Stub implementation
    envelope['event_plaintext'] = {
        'type': envelope.get('event_type', 'unknown'),
        'content': 'stub_decrypted_content'
    }
    
    # Extract event_type from plaintext if not already set
    if 'event_type' not in envelope and 'type' in envelope['event_plaintext']:
        envelope['event_type'] = envelope['event_plaintext']['type']
    
    # Note: event_id is generated by signature_handler from canonical signed plaintext
    # It should already be present in the envelope
    
    envelope['write_to_store'] = True
    
    return envelope


def encrypt_event(envelope: dict[str, Any]) -> dict[str, Any]:
    """Encrypt a validated plaintext event."""
    # TODO: Implement actual encryption logic
    
    # Would normally:
    # 1. Determine which key to use for encryption (from network/group context)
    # 2. Serialize event_plaintext to canonical 512-byte form
    # 3. Encrypt the serialized data
    # 4. Set key_ref to indicate which key was used
    
    event_plaintext = envelope.get('event_plaintext', {})
    
    # Stub: Use a deterministic "encryption" for testing
    plaintext_str = str(event_plaintext)
    envelope['event_ciphertext'] = f"encrypted:{plaintext_str}".encode()
    
    # Determine key_ref (would normally come from group/network context)
    if 'group_id' in event_plaintext:
        # Group events use symmetric key encryption
        envelope['key_ref'] = {
            'kind': 'key',
            'id': f"group_key_{event_plaintext['group_id']}"
        }
    else:
        # Network events might use peer encryption
        peer_id = event_plaintext.get('peer_id', envelope.get('peer_id', 'default_peer'))
        envelope['key_ref'] = {
            'kind': 'peer',
            'id': peer_id
        }
    
    # Note: event_id should already be present from signature_handler
    # The event_id is the blake2b-16 hash of the canonical signed plaintext
    if 'event_id' not in envelope:
        envelope['error'] = "No event_id found - should be set by signature_handler"
    
    envelope['write_to_store'] = True
    
    return envelope


def seal_event(envelope: dict[str, Any]) -> dict[str, Any]:
    """
    Seal an event to a peer's public key (one-way encryption).

    Used for sync requests where the sender can't decrypt their own message.
    """
    from core.crypto import seal
    import json

    seal_to = envelope.get('seal_to')  # Peer ID to seal to
    event_plaintext = envelope.get('event_plaintext')

    if not seal_to or not event_plaintext:
        envelope['error'] = "seal_to and event_plaintext required for sealing"
        return envelope

    # TODO: Get peer's public key from database
    # For now, stub implementation
    peer_public_key = b'stub_public_key_for_' + seal_to.encode()[:32].ljust(32, b'\0')

    # Serialize plaintext
    plaintext_bytes = json.dumps(event_plaintext).encode('utf-8')

    # Seal to peer's public key
    try:
        # In real implementation, would use actual seal function
        # envelope['event_sealed'] = seal(plaintext_bytes, peer_public_key)
        envelope['event_sealed'] = b'sealed:' + plaintext_bytes  # Stub

        # Remove plaintext after sealing
        del envelope['event_plaintext']

        # Mark for outgoing if specified
        if envelope.get('is_outgoing'):
            envelope['write_to_store'] = False  # Don't store outgoing sync requests

    except Exception as e:
        envelope['error'] = f"Failed to seal: {e}"

    return envelope


def open_sealed_event(envelope: dict[str, Any]) -> dict[str, Any]:
    """
    Open a sealed event using our private key.

    Used for receiving sync requests sealed to our public key.
    """
    from core.crypto import unseal
    import json

    event_sealed = envelope.get('event_sealed')
    if not event_sealed:
        envelope['error'] = "event_sealed required for opening"
        return envelope

    # TODO: Get our private key from database
    # For now, stub implementation
    our_private_key = b'stub_private_key'.ljust(32, b'\0')
    our_public_key = b'stub_public_key'.ljust(32, b'\0')

    try:
        # In real implementation, would use actual unseal function
        # plaintext_bytes = unseal(event_sealed, our_private_key, our_public_key)

        # Stub: just remove prefix
        if event_sealed.startswith(b'sealed:'):
            plaintext_bytes = event_sealed[7:]
        else:
            plaintext_bytes = event_sealed

        # Parse plaintext
        event_plaintext = json.loads(plaintext_bytes.decode('utf-8'))
        envelope['event_plaintext'] = event_plaintext

        # Sync requests are not stored
        if event_plaintext.get('type') == 'sync_request':
            envelope['write_to_store'] = False
            envelope['is_sync_request'] = True

    except Exception as e:
        envelope['error'] = f"Failed to open sealed: {e}"

    return envelope


class EventCryptoHandler(Handler):
    """Handler for event crypto."""

    @property
    def name(self) -> str:
        return "event_crypto"

    def filter(self, envelope: dict[str, Any]) -> bool:
        """Check if this handler should process the envelope."""
        return filter_func(envelope)

    def process(self, envelope: dict[str, Any], db: sqlite3.Connection) -> List[dict[str, Any]]:
        """Process the envelope."""
        result = handler(envelope)
        if result:
            return [result]
        return []
