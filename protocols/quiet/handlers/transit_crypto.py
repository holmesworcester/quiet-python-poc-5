"""
Transit Crypto handler - Handles both transit encryption and decryption.

From plan.md:
- Decrypt Filter: `deps_included_and_valid: true` AND has `transit_key_id` AND `transit_ciphertext` AND NOT `key_ref`
- Encrypt Filter: `outgoing_checked: true` AND has `event_ciphertext` AND `transit_key_id`
- Transform: Encrypts/decrypts transit layer
"""
from typing import Any, List
import sqlite3
from core.handlers import Handler

# Removed core.types import


def filter_func(envelope: dict[str, Any]) -> bool:
    """
    Process envelopes that need transit encryption or decryption.
    """
    # Decrypt case: incoming with transit encryption
    if (envelope.get('deps_included_and_valid') is True and
        'transit_key_id' in envelope and
        'transit_ciphertext' in envelope and
        'key_ref' not in envelope):
        return True
    
    # Encrypt case: outgoing that needs transit encryption
    if (envelope.get('outgoing_checked') is True and
        'event_ciphertext' in envelope and
        'transit_key_id' in envelope):
        return True
    
    return False


def handler(envelope: dict[str, Any]) -> dict[str, Any]:
    """
    Handle transit layer encryption/decryption.
    
    Args:
        envelope: dict[str, Any] needing transit crypto operations
        
    Returns:
        Transformed envelope
    """
    # Determine if this is encryption or decryption
    if 'transit_ciphertext' in envelope and 'key_ref' not in envelope:
        # Decryption case
        return decrypt_transit(envelope)
    else:
        # Encryption case
        return encrypt_transit(envelope)


def decrypt_transit(envelope: dict[str, Any]) -> dict[str, Any]:
    """Decrypt transit layer to reveal event encryption layer."""
    # TODO: Implement actual decryption logic
    
    # Extract transit key from resolved_deps
    transit_key_id = envelope['transit_key_id']
    resolved_deps = envelope.get('resolved_deps', {})
    transit_key_dep = f"transit_key:{transit_key_id}"
    transit_key_data = resolved_deps.get(transit_key_dep, {})
    transit_secret = transit_key_data.get('transit_secret', b'stub_transit_secret')
    
    # Would normally:
    # 1. Decrypt transit_ciphertext using transit_secret
    # 2. Extract network_id, key_ref, event_ciphertext
    # 3. Parse key_ref to determine encryption type
    
    # Stub implementation
    envelope['network_id'] = transit_key_data.get('network_id', 'stub_network_id')
    envelope['event_ciphertext'] = b'stub_event_ciphertext'
    
    # Extract key_ref from decrypted transit data
    # This would normally come from the decrypted transit plaintext
    # For stub, determine based on context
    if envelope.get('peer_id'):
        # Peer-encrypted event (e.g., key event sealed to peer)
        envelope['key_ref'] = {
            'kind': 'peer',
            'id': envelope['peer_id']
        }
    else:
        # Group/network encrypted event
        envelope['key_ref'] = {
            'kind': 'key',
            'id': 'stub_key_event_id'
        }
    
    # Note: event_id will be generated by signature_handler after decryption
    # and signature verification from the canonical signed plaintext
    envelope['write_to_store'] = True
    
    # Preserve network metadata
    for field in ['received_at', 'origin_ip', 'origin_port']:
        if field in envelope:
            envelope[field] = envelope[field]
    
    return envelope


def encrypt_transit(envelope: dict[str, Any]) -> dict[str, Any]:
    """Apply transit layer encryption to outgoing envelope."""
    # TODO: Implement actual transit encryption logic
    
    # Extract transit key from resolved_deps
    transit_key_id = envelope['transit_key_id']
    resolved_deps = envelope.get('resolved_deps', {})
    transit_key_dep = f"transit_key:{transit_key_id}"
    transit_key_data = resolved_deps.get(transit_key_dep, {})
    transit_secret = transit_key_data.get('transit_secret', b'stub_transit_secret')
    
    # Would normally:
    # 1. Create transit plaintext containing event_ciphertext and metadata
    # 2. Encrypt using transit_secret
    # 3. Strip all sensitive data from envelope
    
    # Stub: Wrap event ciphertext in transit "encryption"
    event_ciphertext = envelope['event_ciphertext']
    transit_plaintext = {
        'event_ciphertext': event_ciphertext,
        'key_ref': envelope.get('key_ref'),
        'network_id': envelope.get('network_id')
    }
    
    # Create new envelope with only transit-layer data
    transit_envelope: dict[str, Any] = {
        'transit_ciphertext': f"transit_encrypted:{transit_plaintext}".encode(),
        'transit_key_id': transit_key_id,
        'dest_ip': envelope.get('dest_ip', '127.0.0.1'),
        'dest_port': envelope.get('dest_port', 8080),
        'due_ms': envelope.get('due_ms', 0)
    }
    
    return transit_envelope

class TransitCryptoHandler(Handler):
    """Handler for transit crypto."""

    @property
    def name(self) -> str:
        return "transit_crypto"

    def filter(self, envelope: dict[str, Any]) -> bool:
        """Check if this handler should process the envelope."""
        return filter_func(envelope)

    def process(self, envelope: dict[str, Any], db: sqlite3.Connection) -> List[dict[str, Any]]:
        """Process the envelope."""
        result = handler(envelope)
        if result:
            return [result]
        return []
